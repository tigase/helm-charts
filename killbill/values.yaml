imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

killbill:
  version: "0.24"
  image:
    repository: killbill/killbill
    pullPolicy: IfNotPresent
    tag: ""  # default is .Chart.AppVersion

  enableAdminUser: false
  admin:
    password: ""
        
  plugins:
    persistentVolume:
      enabled: false
      storage: 1Gi
        
  resources: {}
  affinity: {}
  nodeSelector:
    kubernetes.io/arch: amd64
  
  service:
    annotations: {}
    type: LoadBalancer     # Since the service is exposed outside the cluster, this cannot be ClusterIP.
    port: 8080
    whitelistSourceRange: "141.148.186.226/32"  # Points to IP of Uptime Kuma IP; can be expanded to include
                                                # IP of other management servers from where we might want to
                                                # troubleshoot the inventory checker.

# Inventory checker sidecar attributes, with service/ingress port.
#
sidecar:
  enabled: true  # Tentatively disable sidecar, till docker image tag of sidecar is finalize.
  name: "inventory-checker"  # Sidecar container name
  image: "rktigasedocker/inventory-checker"
  tag: "v1.0.20-contentlength" # Sidecar image tag "latest" also exists.
  
  service:
    enabled: true  # Tentatively disable this service
    port: 8081     # Port for the service - this should match what is in inventory checker Dockerfile
    type: ClusterIP  # LoadBalancer is not needed since Ingress controller can route
                     # external traffic to ClusterIP.
  ingressHost: "inventory-checker.tigase.net"  # FQDN for the inventory checker service


kaui:
  image:
    repository: killbill/kaui
    pullPolicy: IfNotPresent
    tag: "3.0.17"

  rootUser: "admin"

  service:
    annotations: {}
    type: ClusterIP
    port: 8080

database:
  host: mysql
  port: 3306
  killbill: "killbill"
  kaui: "kaui"
  existingSecret: mysql-credentials
  loadSchema: false

ingress:
  enabled: false
  className: ""
  annotations: {}
    # kubernetes.io/ingress.class: nginx
  # kubernetes.io/tls-acme: "true"
  hosts:
    - host: killbill
      paths:
        - path: /
          pathType: ImplementationSpecific
          serviceType: "killbill"
    - host: kaui
      paths:
        - path: /
          pathType: ImplementationSpecific
          serviceType: "kaui"
  ## Name of the SSL certificate provider to use from:
  ## - self-signed
  ## - letsencrypt
  sslProvider: "self-signed"
  certificateIssuer: ""
  tls: {}
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local
  
podAnnotations: {}

podSecurityContext: {}
# fsGroup: 2000

securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
# runAsUser: 1000

